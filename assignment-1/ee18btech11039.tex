\documentclass[journal,12pt,twocolumn]{IEEEtran}

\usepackage{setspace}
\usepackage{gensymb}
\singlespacing
\usepackage[cmex10]{amsmath}

\usepackage{amsthm}

\usepackage{mathrsfs}
\usepackage{txfonts}
\usepackage{stfloats}
\usepackage{bm}
\usepackage{cite}
\usepackage{cases}
\usepackage{subfig}

\usepackage{longtable}
\usepackage{multirow}

\usepackage{enumitem}
\usepackage{mathtools}
\usepackage{steinmetz}
\usepackage{tikz}
\usepackage{circuitikz}
\usepackage{verbatim}
\usepackage{tfrupee}
\usepackage[breaklinks=true]{hyperref}
\usepackage{graphicx}
\usepackage{tkz-euclide}
\usetikzlibrary{calc, shapes, shapes.multipart,chains,arrows}

\usetikzlibrary{calc,math}
\usepackage{listings}
    \usepackage{color}                                            %%
    \usepackage{array}                                            %%
    \usepackage{longtable}                                        %%
    \usepackage{calc}                                             %%
    \usepackage{multirow}                                         %%
    \usepackage{hhline}                                           %%
    \usepackage{ifthen}                                           %%
    \usepackage{lscape}     
\usepackage{multicol}
\usepackage{chngcntr}

\DeclareMathOperator*{\Res}{Res}

\renewcommand\thesection{\arabic{section}}
\renewcommand\thesubsection{\thesection.\arabic{subsection}}
\renewcommand\thesubsubsection{\thesubsection.\arabic{subsubsection}}

\renewcommand\thesectiondis{\arabic{section}}
\renewcommand\thesubsectiondis{\thesectiondis.\arabic{subsection}}
\renewcommand\thesubsubsectiondis{\thesubsectiondis.\arabic{subsubsection}}


\hyphenation{op-tical net-works semi-conduc-tor}
\def\inputGnumericTable{}                                 %%

\lstset{
%language=C,
frame=single, 
breaklines=true,
columns=fullflexible
}
\begin{document}


\newtheorem{theorem}{Theorem}[section]
\newtheorem{problem}{Problem}
\newtheorem{proposition}{Proposition}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{example}{Example}[section]
\newtheorem{definition}[problem]{Definition}

\newcommand{\BEQA}{\begin{eqnarray}}
\newcommand{\EEQA}{\end{eqnarray}}
\newcommand{\define}{\stackrel{\triangle}{=}}
\bibliographystyle{IEEEtran}
\raggedbottom
\setlength{\parindent}{0pt}
\providecommand{\mbf}{\mathbf}
\providecommand{\pr}[1]{\ensuremath{\Pr\left(#1\right)}}
\providecommand{\qfunc}[1]{\ensuremath{Q\left(#1\right)}}
\providecommand{\sbrak}[1]{\ensuremath{{}\left[#1\right]}}
\providecommand{\lsbrak}[1]{\ensuremath{{}\left[#1\right.}}
\providecommand{\rsbrak}[1]{\ensuremath{{}\left.#1\right]}}
\providecommand{\brak}[1]{\ensuremath{\left(#1\right)}}
\providecommand{\lbrak}[1]{\ensuremath{\left(#1\right.}}
\providecommand{\rbrak}[1]{\ensuremath{\left.#1\right)}}
\providecommand{\cbrak}[1]{\ensuremath{\left\{#1\right\}}}
\providecommand{\lcbrak}[1]{\ensuremath{\left\{#1\right.}}
\providecommand{\rcbrak}[1]{\ensuremath{\left.#1\right\}}}
\theoremstyle{remark}
\newtheorem{rem}{Remark}
\newcommand{\sgn}{\mathop{\mathrm{sgn}}}
\providecommand{\abs}[1]{\left\vert#1\right\vert}
\providecommand{\res}[1]{\Res\displaylimits_{#1}} 
\providecommand{\norm}[1]{\left\lVert#1\right\rVert}
%\providecommand{\norm}[1]{\lVert#1\rVert}
\providecommand{\mtx}[1]{\mathbf{#1}}
\providecommand{\mean}[1]{E\left[ #1 \right]}
\providecommand{\fourier}{\overset{\mathcal{F}}{ \rightleftharpoons}}
%\providecommand{\hilbert}{\overset{\mathcal{H}}{ \rightleftharpoons}}
\providecommand{\system}{\overset{\mathcal{H}}{ \longleftrightarrow}}
	%\newcommand{\solution}[2]{\textbf{Solution:}{#1}}
\newcommand{\solution}{\noindent \textbf{Solution: }}
\newcommand{\cosec}{\,\text{cosec}\,}
\providecommand{\dec}[2]{\ensuremath{\overset{#1}{\underset{#2}{\gtrless}}}}
\newcommand{\myvec}[1]{\ensuremath{\begin{pmatrix}#1\end{pmatrix}}}
\newcommand{\mydet}[1]{\ensuremath{\begin{vmatrix}#1\end{vmatrix}}}
\numberwithin{equation}{subsection}
\makeatletter
\@addtoreset{figure}{problem}
\makeatother
\let\StandardTheFigure\thefigure
\let\vec\mathbf
\renewcommand{\thefigure}{\theproblem}
\def\putbox#1#2#3{\makebox[0in][l]{\makebox[#1][l]{}\raisebox{\baselineskip}[0in][0in]{\raisebox{#2}[0in][0in]{#3}}}}
     \def\rightbox#1{\makebox[0in][r]{#1}}
     \def\centbox#1{\makebox[0in]{#1}}
     \def\topbox#1{\raisebox{-\baselineskip}[0in][0in]{#1}}
     \def\midbox#1{\raisebox{-0.5\baselineskip}[0in][0in]{#1}}
\vspace{3cm}
\title{EE4013 Assignment-1}
\author{Shaik Mastan Vali - EE18BTECH11039}
\maketitle
\newpage
\bigskip
\renewcommand{\thefigure}{\theenumi}
\renewcommand{\thetable}{\theenumi}
Download all the codes from 
\begin{lstlisting}
https://github.com/Mastan1301/EE4013/tree/main/assignment-1/codes
\end{lstlisting}
%
and latex-tikz codes from 
%
\begin{lstlisting}
https://github.com/Mastan1301/EE4013/tree/main/assignment-1
\end{lstlisting}

\section{Problem}
Consider the following matrix:
\begin{align*}
    X = \begin{bmatrix}
        1 & 2 & 4 & 8 \\
        1 & 3 & 9 & 27 \\
        1 & 4 & 16 & 64 \\
        1 & 5 & 25 & 125
    \end{bmatrix}
\end{align*}
Calculate the absolute value of the product of the Eigen values of $X$.

\section{\textbf{Solution-1}}
We use the following property -
\begin{align*}
    \prod_{i = 0}^{k - 1} \lambda_{i} = det(X)
\end{align*}
where $\lambda_{i}$ are the Eigen values and $det(.)$ is the determinant operator. 
\subsection{Algorithm}
To find the determinant, we use the following recurrence relation.
\begin{align*}
    det(X, n) = \sum_{j = 0}^{n - 1} (-1) ^ {j} \times X[0][j] \times det(cof(X, 0, j), n - 1)
\end{align*}
where $cof(i, j)$ is the cofactor matrix of the position $(i, j)$ in the matrix R. \\ \\

The recursion, for our example, is given in the flow chart. \\ \\

\begin{figure}[h!]
	\begin{center}
		\resizebox{\columnwidth/1}{!}{\input{./figs/fig1.tex}}
	\end{center}
	\caption{The flow of recursion}
	\label{fig:fig1}
\end{figure}

\\ \\ \\ To understand the process, consider $C_1 = cof(X, 0, 0)$. \\ \\

\begin{figure}[h!]
	\begin{center}
		\resizebox{\columnwidth/1}{!}{\input{./figs/fig2.tex}}
	\end{center}
	\caption{A $3 \times 3$ sub-problem}
	\label{fig:fig2}
\end{figure}

Now, consider $C_2 = cof(C_1, 0, 0)$. 

\begin{figure}[h!]
	\begin{center}
		\resizebox{\columnwidth/1}{!}{\input{./figs/fig3.tex}}
	\end{center}
	\caption{A $2 \times 2$ sub-problem}
	\label{fig:fig3}
\end{figure}

The determinant of a $1 \times 1$ matrix is the value of the element itself. We use this property as the base case.

The absolute value of the determinant of the given matrix is 12. Hence, the answer is 12.

The algorithm is in the following file - 
\begin{lstlisting}
https://github.com/Mastan1301/EE4013/tree/main/assignment-1/codes/det/main.c
\end{lstlisting}

\subsection{Complexity of the algorithm}
At each stage of recursion of depth $k$, there are $O(n - k)$ recursive calls. Hence, the time complexity is 
    \begin{align*}
        O(n \times (n - 1) \times .... \times 1) = O(n!)
    \end{align*}

\section{\textbf{Solution-2}}
In this solution, we use the QR-algorithm to compute the Eigen values. The algorithm is as follows-
\begin{itemize}
    \item Apply the QR decomposition so that
            \begin{align*}
                X = Q_0R_0
            \end{align*}
            where $Q_0$ is an orthogonal matrix and $R_0$ is an upper-triangular matrix.
    \item Compute 
          \begin{align*}
                E_0 = Q_0^{-1} X Q_0 = Q_0 ^ T X Q_0
            \end{align*} 
            Note that the Eigen values of $X$ and $E_0$ are the same.
    \item Next, we decompose the $E_0$ and repeat this procedure till we obtain a triangular matrix. The Eigen values of a triangular matrix are given by the diagonal entries of the matrix.
\end{itemize}

\\
We compute the QR decomposition using the Householder transformation.
\subsection{Householder Transformation}
The reflection hyperplane can be defined by a unit vector $u$ that is orthogonal to the hyperplane, which is its normal vector. The reflection of a vector $x$ about this hyperplane is the linear transformation:
    \begin{align*}
        y &= x - 2 (u^T x) u \\
        &= x - 2 u (u ^T x) \\
        &= x - 2 (u u ^T) x \\
        &= (I - 2 u u^T) x
    \end{align*}
    The matrix constructed from this transformation can be expressed in terms of an outer product as:
    \begin{align*}
        H = H=I-2 u u^{T}
    \end{align*}
    is called as the \textbf{Householder matrix}.

\subsection{Algorithm}
We compute the QR decomposition using the Householder transformation.
    Multiplying a given vector $x$, for example the first column of matrix $X$, with the Householder matrix $H$, which is given as
    \begin{align*}
        H=I-\frac{2}{u^{T} u} u u^{T}
    \end{align*}
    
    reflects $x$ about a plane given by its normal vector $u$. When the normal vector of the plane $u$ is given as
    \begin{align*}
        u=x-\|x\|_{2} e_{1}
    \end{align*}
    then the transformation reflects $x$ onto the first standard basis vector
    \begin{align*}
            e_{1}=\left[\begin{array}{llll}
            1 & 0 & 0 & \ldots
        \end{array}\right]^{T}
    \end{align*}
    which means that all entries but the first become zero.
    
    In general, if we take $u=x-s\|x\| e_{1}$ where $s=\pm 1$ and $v=u /\|u\|$ then
    $$
    H x=\left(I-2 \frac{u u^{T}}{u^{T} u}\right) x=s\|x\| e_{1} .
    $$
    Let us first verify that this works:
    \begin{align*}
    u^{T} x &=\left(x-s\|x\| e_{1}\right)^{T} x \\
    &=\|x\|^{2}-s x_{1}\|x\| \\
    u^{T} u &=\left(x-s\|x\| e_{1}\right)^{T}\left(x-s\|x\| e_{1}\right) \\
    &=\|x\|^{2}-2 s x_{1}\|x\|+\|x\|^{2}\left\|e_{1}\right\|^{2} \\
    &=2\left(\|x\|^{2}-s x_{1}\|x\|\right)=2 u^{T} x \\
    H x &=x-2 u \frac{u^{T} x}{u^{T} u}=x-u=s\|x\| e_{1} .
    \end{align*}
    As a byproduct of this calculation, note that we have
    $$
    u^{T} u=-2 s\|x\| u_{1} = -2x_1 + 2 s \|x\|
    $$
    Hence, to ensure $u^{T} u > 0$ always, we take $s = -sign(x_1)$.\\
    $$\implies Hx = -sign(x_1) \|x\| e_1$$
    First, we multiply $X$ with the Householder matrix $H_{1}$ we obtain when we choose the first matrix column for $X$. This results in a matrix $H_{1} X$ with zeros in the left column (except for the first row).
    $$
    H_{1} X=\left[\begin{array}{cccc}
    -sign(X_{11})\alpha_{1} & * & \cdots & * \\
    0 & & & \\
    \vdots & & X^{\prime} & \\
    0 & & &
    \end{array}\right]
    $$
    where $\alpha_1$ is the 2-norm of the first column of $X$.\\
    This can be repeated for $X^{\prime}$ (obtained from $H_{1} X$ by deleting the first row and first column), resulting in a Householder matrix $H_{2}^{\prime} .$ Note that $H_{2}^{\prime}$ is smaller than $H_{1}$. Since we want it really to operate on $H_{1} X$ instead of $X^{\prime}$ we need to expand it to the upper left, filling in a 1 , or in general:
    $$
    H_{k}=\left[\begin{array}{cc}
    I_{k-1} & 0 \\
    0 & H_{k}^{\prime}
    \end{array}\right]
    $$
    This is how we can, column by column, remove all sub-diagonal elements of $A$ and thus transform it into $R$.
$$H_{n} \ldots H_{3} H_{2} H_{1} X=R$$
The product of all the Householder matrices $H$, for every column, in reverse order, will then yield the orthogonal matrix $Q$.
$$
H_{1} H_{2} H_{3} \ldots H_{n}=Q
$$

\begin{figure}[h!]
	\begin{center}
		\resizebox{\columnwidth/1}{!}{\input{./figs/fig4.tex}}
	\end{center}
	\caption{The QR algorithm}
	\label{fig:fig4}
\end{figure}

Using this algorithm, the obtained Eigen values are 139.410, 5.003. 0.555, 0.0311. The absolute value of the product is 12. 

The algorithm is in the following file- 
\begin{lstlisting}
https://github.com/Mastan1301/EE4013/tree/main/assignment-1/codes/QR_arrays/main.c
\end{lstlisting}
The utility functions are in the following header file- 
\begin{lstlisting}
https://github.com/Mastan1301/EE4013/tree/main/assignment-1/codes/QR_arrays/utils.h
\end{lstlisting}
\\ ~ \\
Compile the code using-
\begin{lstlisting}
gcc main.c -o main -lm
\end{lstlisting}
Run the code using-
\begin{lstlisting}
./main
\end{lstlisting}

The C++ program (using vectors) is in the following file-
\begin{lstlisting}
https://github.com/Mastan1301/EE4013/tree/main/assignment-1/codes/QR_vectors/main.cpp
\end{lstlisting}
Compile the code using-
\begin{lstlisting}
g++ main.c -o main -lm
\end{lstlisting}
Run the code using-
\begin{lstlisting}
./main
\end{lstlisting}

\subsection{Complexity of the QR algorithm using arrays/vectors}
The QR decomposition step takes $O(n ^ 4)$ computations, because the matrix multiplication at each iteration takes $O(n^3)$ time, and there are $O(n)$ iterations. \\
    The matrix convergence is achieved in $O(\max_{i, j} |\lambda_i / \lambda_j| ^ n)$ steps. Hence the total time complexity is $O((\max_{i, j} |\lambda_i / \lambda_j| ^ n) \times n ^ 4)$.
    
\subsection{QR algorithm using linked lists}
In this algorithm, we use linked lists to store the matrices. The list is defined by a \textit{head} node. The function \textit{at(head, i, j)} returns the pointer to the node at $i^{th}$ row and $j^{th}$ column. 

\begin{figure}[h!]
	\begin{center}
		\resizebox{\columnwidth/1}{!}{\input{./figs/fig5.tex}}
	\end{center}
	\caption{A $4 \times 4$ matrix implementation using linked list}
	\label{fig:fig5}
\end{figure}


The code is in the following file-
\begin{lstlisting}
https://github.com/Mastan1301/EE4013/tree/main/assignment-1/codes/QR_linked_list/main.c
\end{lstlisting}

\subsection{Complexity of the QR algorithm using linked lists}   
To access the element in the $i^{th}$ row and $j^{th}$ column, we need $O(i + j)$ iterations. Hence, the time complexity of accessing an element is $O(n)$. This additional factor in the algorithm gives us $O((\max_{i, j} |\lambda_i / \lambda_j| ^ n) \times n ^ 5)$ complexity. However, using lists gives us better memory management due to non-continuguous memory allocation.

\subsection{Comparison of runtimes of QR algorithm using different data structures}
\begin{tabular}{| c | c |}
     \hline
     \textbf{Data Structure} &  \textbf{Time (in ms.)}\\
     \hline
     Arrays & 0.472 \\ 
     \hline
     Vectors (in C++) & 0.886 \\
     \hline
     Linked lists & 0.925 \\
     \hline
\end{tabular}
\end{document}

